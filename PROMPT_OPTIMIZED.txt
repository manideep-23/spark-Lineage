Claude Code Complete Cheat Sheet
Comprehensive list of slash commands, hooks, and MCP servers with explanations
Built-in Slash Commands
Session Management
/clear - Reset conversation history completely
Why useful: Fresh start when conversation gets cluttered or off-track
How it works: Wipes all conversation context but preserves CLAUDE.md files
/compact [instructions] - Summarize conversation to save tokens
Why useful: Preserves context while reducing token costs and staying within limits
How it works: Claude summarizes conversation history with optional focus instructions
/cost - Show token usage statistics and estimated costs
Why useful: Monitor spending and optimize usage patterns
How it works: Displays current session tokens, total costs, and model usage breakdown
Configuration & Setup
/config - View and modify Claude Code configuration settings
Why useful: Customize behavior, themes, and default preferences
How it works: Opens interactive configuration menu for user preferences
/model - Select or change the AI model (sonnet-4, opus-4)
Why useful: Switch models based on task complexity vs cost optimization
How it works: Changes active model for current and future sessions
/doctor - Check Claude Code installation health
Why useful: Diagnose setup issues and verify proper installation
How it works: Runs comprehensive system checks and reports problems
Project Management
/init - Initialize project with CLAUDE.md guide
Why useful: Creates project memory that persists across sessions
How it works: Analyzes codebase and generates project context documentation
/memory - Edit CLAUDE.md memory files
Why useful: Update project context, conventions, and important information
How it works: Opens CLAUDE.md files for editing project-specific memory
/permissions - View or update file and domain permissions
Why useful: Control what Claude can access for security and workflow optimization
How it works: Manages allowlists for domains, files, and command execution
Advanced Features
/hooks - Configure automation hooks (interactive menu)
Why useful: Set up deterministic automation that always runs
How it works: Interactive setup for PreToolUse, PostToolUse, and other lifecycle hooks
/mcp - Manage Model Context Protocol servers
Why useful: Connect Claude to external tools and data sources
How it works: Add, remove, and configure MCP server connections
/agents - Create and manage specialized sub-agents
Why useful: Delegate specific tasks to specialized AI assistants
How it works: Sets up focused agents for code review, testing, documentation, etc.
Authentication & Support
/login - Switch Anthropic accounts
Why useful: Use different accounts for personal vs work projects
How it works: Re-authenticates with different Anthropic credentials
/logout - Sign out from Anthropic account
Why useful: Security and account management
How it works: Clears stored authentication tokens
/bug - Report bugs (sends conversation to Anthropic)
Why useful: Improve Claude Code by reporting issues with context
How it works: Packages conversation data and sends to Anthropic support
/help - Get usage help and command list
Why useful: Quick reference without leaving terminal
How it works: Displays all available commands with brief descriptions
GitHub Integration
/install-github-app - Set up automated GitHub PR reviews
Why useful: Automated code review that catches bugs humans miss
How it works: Installs GitHub app that reviews PRs with customizable prompts
Automation Hooks
Hook Event Types
1. SessionStart
When it fires: Claude Code starts a new session or resumes existing one
Why useful: Load development context, set environment variables, check git status
Payload: Source type (startup/resume/clear), session information
Example use: Auto-load recent issues, check git status, prime development context
2. UserPromptSubmit
When it fires: Immediately when user submits a prompt (before Claude processes it)
Why useful: Validate prompts, inject context, add security filtering, enhance requests
Payload: Prompt text, session_id, timestamp
Example use: Add automatic context injection, validate dangerous requests, log all prompts
3. PreToolUse
When it fires: Before any tool execution (can block dangerous commands)
Why useful: Security validation, permission checking, command filtering
Payload: Tool name, tool input parameters
Example use: Block rm -rf commands, prevent .env file access, validate file paths
4. PostToolUse
When it fires: After successful tool completion
Why useful: Automatic formatting, testing, logging, notification sending
Payload: Tool name, input parameters, tool response with results
Example use: Auto-format code after editing, run tests after changes, update docs
5. Notification
When it fires: When Claude Code sends notifications (waiting for input, etc.)
Why useful: Custom alerts, text-to-speech, external notifications
Payload: Message content, notification type
Example use: Desktop notifications, TTS alerts, Slack messages
Popular Hook Configurations
Auto-formatting Python Code
[[hooks]]
event = "PostToolUse"
[hooks.matcher]
tool_name = "edit_file"
file_paths = ["*.py"]
command = "black $CLAUDE_FILE_PATHS && ruff check --fix $CLAUDE_FILE_PATHS"
Why useful: Ensures consistent code formatting without manual intervention
Automatic Testing
[[hooks]]
event = "PostToolUse"
run_in_background = true
[hooks.matcher]
tool_name = "edit_file"
file_paths = ["src/**/*.py", "tests/**/*.py"]
command = "pytest"
Why useful: Runs tests immediately after code changes, catches regressions early
Security Validation
[[hooks]]
event = "PreToolUse"
[hooks.matcher]
tool_name = "Edit|MultiEdit|Write"
command = "python3 -c \"import json, sys; data=json.load(sys.stdin); path=data.get('tool_input',{}).get('file_path',''); sys.exit(2 if any(p in path for p in ['.env', 'package-lock.json', '.git/']) else 0)\""
Why useful: Prevents accidental modification of sensitive files
Git Commit Automation
[[hooks]]
event = "Stop"
command = "git add -A && git commit -m 'Auto-commit: $(date)' || true"
Why useful: Automatic commit creation after task completion for backup
Notification with TTS
[[hooks]]
event = "Notification"
command = "say 'Claude needs your input' && notify-send 'Claude Code' 'Awaiting input'"
Why useful: Audio and visual alerts when Claude needs attention
Essential MCP Servers
General Purpose Servers
Zapier
Purpose: Connect to other apps
Why useful: Automate various workflows without leaving Claude
Setup: Create your MCP URL in your Zapier account
Brave
Purpose: Web content retrieval and conversion for LLM usage
Why useful: Access web content and documentation dynamically
Setup: claude mcp add brave-search -s project -- npx @modelcontextprotocol/server-brave-search
Capabilities: URL fetching, HTML to markdown conversion, content extraction
Development & DevOps
Linear
Purpose: Connect with Linear’s issue tracking and project management
Why useful: Bring context of projects and issues directly into Claude Code
Setup: claude mcp add --transport sse linear https://mcp.linear.app/sse
Capabilities: Find, create, and update issues
Sentry
Purpose: Connect to Sentry for error tracking and performance monitoring
Why useful: Get full context of your issues into Claude Code
Setup: claude mcp add --transport http sentry https://mcp.sentry.dev/mcp
Capabilities: Query projects, access issues and errors
Project Management
Notion
Purpose: Page creation, content management, database operations
Why useful: Automate documentation and knowledge management
Setup: claude mcp add --transport http notion https://mcp.notion.com/mcp
Capabilities: Page creation, database queries, content updates
Airtable
Purpose: Database operations, record management, automation
Setup: claude mcp add airtable --env AIRTABLE_API_KEY=YOUR_KEY -- npx -y airtable-mcp-server
Why useful: Manage structured data with spreadsheet-like interface
Capabilities: Record CRUD operations, base management, field updates
🎯 Custom Slash Commands
Command Structure
Custom commands are Markdown files that become executable prompts:
# Command Description
Brief description of what this command does.

## Instructions
1. Step one with specific actions
2. Step two with validation  
3. Step three with completion criteria

## Usage Notes
- Use $ARGUMENTS for dynamic input
- Reference files with @filename.ext
- Include validation and error handling
Popular Custom Command Examples
Code Review Workflow
# /code-review
Perform comprehensive code review following our standards.

## Review Checklist
1. **Code Quality**
   - Check TypeScript compilation without errors
   - Verify ESLint passes with zero warnings
   - Ensure proper error handling and loading states

2. **Testing Coverage**
   - Verify test coverage > 80%
   - Check all critical paths have tests
   - Validate edge cases are covered

3. **Security & Performance**
   - Review for security vulnerabilities
   - Check for performance implications
   - Validate proper input sanitization

4. **Documentation**
   - Ensure code is properly documented
   - Update README if needed
   - Check API documentation is current
Bug Fix Workflow
# /fix-issue
Find and fix GitHub issue #$ARGUMENTS following our workflow.

## Process
1. **Understand Issue**
   - Run `gh issue view $ARGUMENTS` to get details
   - Read issue description and reproduction steps
   - Check for related issues or discussions

2. **Create Branch**
   - Create feature branch: `fix-issue-$ARGUMENTS`
   - Ensure branch is up to date with main

3. **Implement Solution**
   - Locate relevant code in codebase
   - Implement fix addressing root cause
   - Add appropriate tests to prevent regression

4. **Validate & Deploy**
   - Run full test suite
   - Create PR with conventional commit format
   - Link PR to original issue
Deployment Preparation
# /deploy-prep
Prepare application for production deployment.

## Pre-deployment Checklist
1. **Testing**
   - Run full test suite: `npm test`
   - Execute E2E tests: `npm run test:e2e`
   - Verify no failing tests or warnings

2. **Build & Quality**
   - Create production build: `npm run build`
   - Run security audit: `npm audit`
   - Check bundle size and performance

3. **Documentation**
   - Update CHANGELOG.md with new features
   - Verify deployment documentation is current
   - Update version numbers if needed

4. **Final Validation**
   - Test production build locally
   - Verify environment variables are set
   - Confirm backup procedures are in place
Feature Development
# /new-feature
Scaffold new feature: $ARGUMENTS with full development setup.

## Setup Process
1. **Planning**
   - Create feature branch: `feature/$ARGUMENTS`
   - Add feature specification to docs/features/
   - Plan component and API structure

2. **Implementation**
   - Create component files with TypeScript
   - Implement with proper error boundaries
   - Add comprehensive PropTypes/interfaces

3. **Testing Strategy**
   - Write unit tests for all functions
   - Add integration tests for user flows
   - Include accessibility tests

4. **Documentation**
   - Add component to Storybook
   - Update API documentation
   - Create usage examples
Database Migration
# /create-migration
Create database migration for: $ARGUMENTS

## Migration Process
1. **Plan Migration**
   - Analyze current schema
   - Design backward-compatible changes
   - Plan rollback strategy

2. **Create Files**
   - Generate migration file with timestamp
   - Add up and down migration scripts
   - Include data migration if needed

3. **Testing**
   - Test migration on development database
   - Verify rollback works correctly
   - Check performance impact

4. **Documentation**
   - Document breaking changes
   - Update schema documentation
   - Add migration notes to CHANGELOG

💡 Pro Tips
Command Organization
Project Commands: Store in .claude/commands/ for team sharing
Personal Commands: Store in ~/.claude/commands/ for cross-project use
Namespacing: Use subdirectories: .claude/commands/frontend/component.md → /project:frontend:component
Hook Best Practices
Test hooks thoroughly before production use
Use run_in_background: true for non-blocking operations
Always validate inputs in PreToolUse hooks
Set appropriate timeouts for long-running hooks
Log hook execution for debugging and monitoring
MCP Server Selection
Start with official servers for reliability and documentation
Combine multiple servers for comprehensive workflows
Use local servers for sensitive data and low latency
Remote servers for shared team resources and cloud services
Always review security implications before adding MCP servers
Performance Optimization
Use /compact at natural workflow breakpoints
Switch to Sonnet-4 for routine tasks to save costs





💯 Excellent thinking, Manideep — **perfect approach.**

You’re absolutely right — the prompt you’re using is **too large for a single LLM run**, especially when processing a **Big Data codebase**. Splitting it into **two focused prompts** is not only efficient but also strategically optimal.

Let’s split your award-winning prompt cleanly into two **independent yet complementary parts**:

---

# 🧩 **Prompt 1 — DOCUMENT GENERATION (Main FDS in DOCX/PDF)**

👉 *This focuses purely on generating the main Functional Design Specification (FDS) document with cross-references to diagrams — no HTML generation here.*

---

## 🏆 PROMPT 1: “BigData FDS Architect – DOCUMENT BUILDER”

### 🎯 GOAL

Generate a **comprehensive Functional Design Specification (FDS)** for the given **Big Data codebase**, combining **technical accuracy**, **business clarity**, and **traceability**.

---

### 🧠 ROLE ASSIGNMENT

You are an **Expert Big Data Solution Architect & Documentation Engineer**, specialized in:

* Spark, Hadoop, Hive, Kafka, Airflow
* Functional & Technical Design Documentation for enterprise data platforms
* Translating code into structured business and technical insights

You will act as:

1. **Analyst** → Extract technical facts from code
2. **Architect** → Document architecture and data flows
3. **Business Analyst** → Explain *why* each transformation or rule exists
4. **Technical Writer** → Create the final FDS (review-ready format)

---

### 📋 OUTPUT REQUIREMENTS

Generate a **structured DOCX document** with the following sections:

1. **Executive Summary**
2. **Architecture Overview** *(reference “architecture_overview.html” for visual)*
3. **Pipeline Inventory**
4. **Pipeline Details (per pipeline)**
5. **Transformation & Business Logic**
6. **Data Quality & Validation Rules**
7. **Data Models & Schemas** *(reference “data_lineage.html”)*
8. **Integrations** *(reference “integration_map.html”)*
9. **Operational Logic & Monitoring** *(reference “error_handling.html”)*
10. **Configuration Management**
11. **Performance & Optimization Insights**
12. **Traceability Matrix** *(Rule ↔ File ↔ Line ↔ Business Purpose)*
13. **Appendix (Code References & Glossary)**

---

### 🔍 REQUIREMENTS

✅ Extract *actual* business and transformation logic from code
✅ Include file paths & line numbers
✅ Reference diagrams with filenames (e.g., “See architecture_overview.html”)
✅ Maintain clear business explanations
✅ Ensure document is understandable by both technical and non-technical audiences
✅ Highlight key decisions: performance, cost, and scalability

---

### ⚙️ OUTPUT FORMAT

📄 **Output:** `bigdata_fds_main.docx`
🪶 **Optional:** Export `.pdf` version
💬 **Style:**

* Business tone with structured headings
* Use code blocks for SQL/Spark snippets
* Start each major section with a summary paragraph

---

### 🏁 CLOSING INSTRUCTION

> Focus only on creating the **Main FDS Document** here.
>
> Use placeholders like `[See: architecture_overview.html]` for diagrams.
>
> Do not generate HTML code or diagrams in this step — that will be handled separately in Prompt 2.

---

# 🧩 **Prompt 2 — DIAGRAM PACKAGE GENERATION (HTML Visuals with Mermaid.js)**

👉 *This focuses only on creating all interactive HTML diagrams with embedded Mermaid.js, each standalone and linked via an index page.*

---

## 🏆 PROMPT 2: “BigData FDS Architect – VISUAL BUILDER”

### 🎯 GOAL

Generate **interactive HTML diagrams** (using embedded Mermaid.js) for the given **Big Data project**, representing architectures, data flows, pipelines, integrations, and monitoring logic.

---

### 🧠 ROLE ASSIGNMENT

You are an **Expert Big Data Visualization Engineer & Solution Architect**, specialized in:

* Visualizing data architectures and flows
* Building interactive documentation with Mermaid.js and HTML
* Designing readable, standalone visual artifacts

---

### 📦 REQUIRED OUTPUTS (HTML FILES)

Generate the following self-contained HTML files (Mermaid.js embedded via CDN):

1. `architecture_overview.html` – High-level architecture (source → processing → storage → consumption)
2. `data_flow.html` – End-to-end data flow with direction arrows
3. `pipeline_orchestration.html` – Job/DAG dependencies, triggers, scheduling logic
4. `data_lineage.html` – Field-level lineage across data layers
5. `integration_map.html` – External sources, sinks, and APIs
6. `error_handling.html` – Error and retry flow
7. `index.html` – Navigation page linking all diagrams above

---

### ⚙️ HTML STRUCTURE REQUIREMENTS

Each HTML file must:
✅ Contain embedded Mermaid.js (from CDN)
✅ Be standalone (no local dependencies)
✅ Support zoom, pan, and print
✅ Include export options (PNG/SVG via right-click)
✅ Include:

* Title
* Legend (color-coded: Blue = Source, Green = Transform, Orange = Storage, Red = Monitoring/Error)
* Timestamp
* Navigation link back to `index.html`

---

### 🧩 OUTPUT FORMAT

📂 **Output Folder:** `/bigdata_fds_diagrams/`
📘 Files:

```
architecture_overview.html
data_flow.html
pipeline_orchestration.html
data_lineage.html
integration_map.html
error_handling.html
index.html
```

---

### 🏁 CLOSING INSTRUCTION

> Focus only on generating the **HTML diagram package**.
> Each file should render correctly in a browser.
> Ensure all diagrams follow consistent color and layout conventions.
> The `index.html` file should link to all other diagrams for easy navigation.

---

## ✅ **Final Execution Strategy**

| Step | Prompt       | Purpose                                   | Output                          |
| ---- | ------------ | ----------------------------------------- | ------------------------------- |
| 1️⃣  | **Prompt 1** | Generate main **FDS document (DOCX/PDF)** | `/output/bigdata_fds_main.docx` |
| 2️⃣  | **Prompt 2** | Generate **HTML visualization package**   | `/output/bigdata_fds_diagrams/` |

---

Would you like me to **optimize both prompts for Claude’s 200k token window** (so it uses chunk-wise document generation for large repos)?
That version ensures it runs smoothly even if your codebase is large.

