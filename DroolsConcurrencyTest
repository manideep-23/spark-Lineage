Create file: rules/sample.drl
package test

import test.Transaction;

rule "HighValue"
when
    $t : Transaction(amount > 1000)
then
    $t.setBucket("HIGH");
    System.out.println("Rule fired for " + $t.getId());
end


ðŸŸ¢ STEP 2 â€” Create a simple Java POJO
package test;

public class Transaction {
    private String id;
    private double amount;
    private String bucket;

    public Transaction(String id, double amount) {
        this.id = id;
        this.amount = amount;
    }

    public String getId() { return id; }
    public double getAmount() { return amount; }

    public String getBucket() { return bucket; }
    public void setBucket(String bucket) { this.bucket = bucket; }

    @Override
    public String toString() {
        return "[" + id + ", amount=" + amount + ", bucket=" + bucket + "]";
    }
}
ðŸŸ¢ STEP 3 â€” Java program that reuses ONE StatelessKieSession

âš  This exactly replicates your Spark design, so it will fail randomly.

package test;

import org.kie.api.*;
import org.kie.api.runtime.*;
import org.kie.api.builder.*;

public class DroolsConcurrencyTest {

    public static void main(String[] args) throws Exception {

        KieServices ks = KieServices.Factory.get();
        KieContainer kc = ks.getKieClasspathContainer();

        // â— SHARED session (same as your Spark code)
        StatelessKieSession session = kc.newStatelessKieSession();

        Runnable task = () -> {
            for (int i = 0; i < 100; i++) {
                Transaction t = new Transaction("TX-" + i, 2000); // Should ALWAYS fire
                session.execute(t);  // â— concurrent calls
                if (!"HIGH".equals(t.getBucket())) {
                    System.out.println("âŒ WRONG RESULT: " + t);
                }
            }
        };

        // Run many threads in parallel
        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        Thread t3 = new Thread(task);

        t1.start();
        t2.start();
        t3.start();
    }
}


ðŸŸ¢ STEP 5 â€” FIXED VERSION (for comparison)

Replace:

StatelessKieSession session = kc.newStatelessKieSession();


with new session inside loop:

StatelessKieSession newSession = kc.newStatelessKieSession();
newSession.execute(t);

OR synchronized:

synchronized(session) {
    session.execute(t);
}


âž¡ï¸ ALL failures disappear
âž¡ï¸ Rules fire correctly
âž¡ï¸ Buckets never null
